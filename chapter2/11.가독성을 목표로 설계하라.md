## (아이템 11) 가독성을 목표로 설계하라

> “개발자가 코드를 작성하는데는 1분 걸리지만, 이를 읽는데는 10분이 걸린다”  
>     - Robert C. Martin (클린코드)

- 코드를 작성하다가 오류가 생기면, 작성하는 시간보다 더 오랜 시간을 코드를 보게된다.
- 그래서 프로그래밍은 쓰기보다 읽기가 중요하다.

.

### 📎인식 부하 감소

**가독성은 사람마다 다르게 느낄 수 있다.**

- 가독성은 코드를 읽고 얼마나 빠르게 이해할 수 있는지를 의미한다.
- 이해하기 쉬운지는 읽는 사람이 얼마나 많은 관용구(구조, 함수, 패턴)에 익숙한지에 따라 달라진다.

```kotlin
// 구현 A
if (person != null && person.isAdult) {
  view.showPerson(person)
} else {
  view.showError()
}

// 구현 B
person?.takeIf { it.isAdult }
  ?.let(view::showPerson)
  ?: view.showError()
```

- 코틀린 초보자는 구현 A가 더 이해하기 쉽다.

  일반적인 관용구(if/else, &&, 메서드 호출)을 사용하기 때문이다.

- 물론 코틀린에 익숙한 개발자라면 `let takeIf elvis`를 사용한 구현 B도 쉽게 읽을 수 있다.

  하지만 숙련된 개발자만을 위한 코드는 절대 좋은 코드가 아니다.

- 코틀린은 대부분의 개발자에게 있어 첫번째 언어가 아니다.

  신입개발자는 물론이고, 숙련된 코틀린 개발자에게도 구현 A가 훨씬 가독성이 좋다.


<br> 

**구현 A가 확장하기도 더 쉽다.**

```kotlin
// 구현 A
if (person != null && person.isAdult) {
  view.showPerson(person)
  view.hideProgressWithSuccess()
} else {
  view.showError()
  view.hideProgress()
}

// 구현 B
person?.takeIf { it.isAdult }
  ?.let {
    view.showPerson(it)
    view.hideProgressWithSuccess()
  } ?: run {
    view.showError()
    view.hideProgress()
  }
```

- 구현 A는 확장을 위해 if/else 블록에 코드를 추가하면 된다.
- 구현 B를 확장하기 위해서는 함수를 추가로 사용해야 한다.

<br> 

**디버깅도 구현 A가 더 쉽다.**

- 디버깅 도구도 이러한 기본 구조를 더 잘 분석해주기 때문이다.

<br> 

**지원도 제대로 받지 못한다.**

- 구현 A는 인텔리제이의 리펙터링 기능을 활용해서 if/else 관련된 부분을 수정할 수 있다.

<br>

**구현 A와 구현 B의 결과가 다르다.**

- 구현 A는 showPerson 또는 show Error 를 호출한다.
- 구현 B에서 let은 람다식의 결과를 리턴한다.
  즉 showPerson 이 null을 리턴하면 showError 도 호출된다.
- **⇒ 익숙하지 않은 구조(구현 B)의 결과를 예측하기 어렵다.**

<br> 

**결론**

- 인지 부하를 줄이는 방향으로 코드를 작성해라.
- 짧은 코드보다 익숙한 코드를 더 빠르게 읽을 수 있다.


<br> 


### 극단적이 되지 않기

앞에서 let 으로 인해 예상치 못한 결과가 나올 수 있다고 했다.

- 그렇다고 let 을 쓰지말고, 무조건 if-else를 쓰는게 좋다고 이해하면 안된다.
- ⇒ 극단적이 되지 말자
  e.g.) let은 좋은 코드를 만들기 위해 널리/다양하게 활용되는 관용구이다.

- nullable 안전 호출

    ```kotlin
    class Person(val name: String)
    var person: Person? = null
    
    // person != null 일 때만 실행하고 싶은 코드가 있는경우
    fun printName() {
    	person?.let {
    		print(it.name)
    	}
    ```

- 연산을 아규먼트 처리 후로 이동시킬 때

    ```kotlin
    students
    	.filter { it.result >= 50 }
    	.joinToString(separator = "\n") {
    		"${it.name} ${it.surname}, ${it.result}"
    	}
    	.let(::print) // print 를 뒤로 이동시킨 경우
    ```

- 데코레이터를 사용해서 객체를 wrap 할 때 ex) `class(myClass(decoClass()))`

    ```kotlin
    var obj = FileInputStream("/file.gz")
    	.let(::BufferedInputStream)
    	.let(::ZipInputStream)
    	.let(::ObjectInputStream)
    	.readObject() as SomeObject
    ```
<br> 

**결론**

- 관용구를 이해하는데 비용이 발생하더라도, 그만한 가치가 있다면 사용해도 좋다.
- 문제가 되는 경우는 그만한 가치가 없을 때(= 이유없이 복잡성을 추가하는 경우) 이다.

<br> 

### 컨벤션

사람에 따라 가독성에 대한 관점이 다르다.

- 함수 이름을 어떻게 지어야 하는지
- 어떤 것이 명시적이고, 어떤 것이 암묵적이어야 하는지
- 어떤 관용구를 사용해야 하는지

프로그래밍은 표현력의 예술이다. 같은 동작이라고 하더라도 개발자마다 코드는 전부 다를 수 있다. 무엇이 최고인지는 상황에 따라 다르겠지만, 적어도 최악의 코드가 무엇인지는 쉽게 찾을 수 있다.

```kotlin
val abc = "A" { "B" } and "C"
print(abc) // ABC
```
이렇게 사용하기 위해서는, 아래와 같은 코드가 필요하다.
```kotlin
operator fun String.invoke(f: ()->String): String = this + f()

infix fun String.and(s: String) = this + s
```

굉장히 간결하고 힙-하게 사용할 수 있어보이지만, 이는 아래의 컨벤션 규칙을 위반한다.
- `연산자는 의미에 맞게 사용해야한다.` invoke는 이렇게 사용하면 안된다.
- `람다를 마지막 인자로 사용한다` 라는 컨벤션을 적용하면 코드가 복잡해진다
- `함수 이름을 보고 동작을 유추할 수 있어야한다.` and를 다른 의미로 사용하고 있다.
- `이미 있는 것을 다시 만들 필요는 없다` 문자열 결합은 이미 코틀린에 내장된 함수가 있다.


읽기 좋은 코드를 만들기 위한 컨벤션을, 아이템 12 ~ 18에 걸쳐 알아보자.